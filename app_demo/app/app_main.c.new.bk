#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <sys/epoll.h>
#include <signal.h>
#include <glib-unix.h>
#include <unistd.h>
#include <errno.h>
#include <pthread.h>
#include <time.h>
#include <math.h>
#include <fcntl.h>
#include <string.h>
#include "gps.h"
#include "bno055_api.h"
#include "camera.h"
#include "ble_button.h"

#define VERSION "v1.00.002"
#define LED_OFF 0
#define LED_SOLID 1
#define LED_BLINK 2
#define GPIO_PIN "111"  // Button GPIO number
#define GPIO_PATH "/sys/class/gpio/gpio" GPIO_PIN "/value"
#define DEBOUNCE_TIME 500  // Debounce time in milliseconds

// Function declarations
void get_time(char *time_buf);
void led_blue_show(unsigned char led);
void led_green_show(bool onoff);
void led_strip_show(bool onoff);
//void led_button_show(bool onoff);
//int get_adc_button(void);
void initialize_camera_system(void);
void cleanup_camera_system(void);
void start_camera_recording(void);
void stop_camera_recording(void);
void *imu_acc_thread(void *arg);
void sig_handler(int sig);

// Global variables
pthread_mutex_t recording_mutex = PTHREAD_MUTEX_INITIALIZER;
pthread_mutex_t sys_suspend_mutex = PTHREAD_MUTEX_INITIALIZER;
static bool recording = false;
static bool sys_suspend = false;

void get_time(char *time_buf) {
    time_t currentTime;
    struct tm *timeInfo;
    time(&currentTime);
    timeInfo = localtime(&currentTime);
    strftime(time_buf, 20, "%m%d%Y-%H%M%S", timeInfo);
}

void led_blue_show(unsigned char led) {
    if (led == LED_BLINK) {
        system("echo heartbeat | sudo tee /sys/class/leds/blue_led/trigger");
        usleep(1000000);
    } else if (led == LED_SOLID) {
        system("echo default-on | sudo tee /sys/class/leds/blue_led/trigger");
        usleep(1000000);
    } else {
        system("echo none | sudo tee /sys/class/leds/blue_led/trigger");
        usleep(1000000);
    }
}

void led_green_show(bool onoff) {
    if (onoff) {
        system("echo default-on | sudo tee /sys/class/leds/green_led/trigger");
    } else {
        system("echo none | sudo tee /sys/class/leds/green_led/trigger");
    }
}

void led_strip_show(bool onoff) {
    if (onoff) {
        system("echo 0 | sudo tee /sys/class/pwm/pwmchip2/export");
        system("echo 1000000 | sudo tee /sys/class/pwm/pwmchip2/pwm0/period");
        system("echo 000000 | sudo tee /sys/class/pwm/pwmchip2/pwm0/duty_cycle");
        system("echo 1 | sudo tee /sys/class/pwm/pwmchip2/pwm0/enable");
    } else {
        system("echo 0 | sudo tee /sys/class/pwm/pwmchip2/export");
        system("echo 1000000 | sudo tee /sys/class/pwm/pwmchip2/pwm0/period");
        system("echo 1000000 | sudo tee /sys/class/pwm/pwmchip2/pwm0/duty_cycle");
        system("echo 1 | sudo tee /sys/class/pwm/pwmchip2/pwm0/enable");
    }
}

#if 0
void led_button_show(bool onoff) {
    if (access("/sys/class/gpio/gpio111", 0)) {
        system("echo 111 | sudo tee /sys/class/gpio/export");
        system("echo out | sudo tee /sys/class/gpio/gpio111/direction");
    }
    if (onoff) {
        system("echo 1 | sudo tee /sys/class/gpio/gpio111/value");
    } else {
        system("echo 0 | sudo tee /sys/class/gpio/gpio111/value");
    }
}

int get_adc_button(void) {
    FILE *fp;
    int value;
    unsigned char read_buf[10];
    fp = fopen("/sys/bus/iio/devices/iio:device0/in_voltage4_raw", "r");
    if (fp == NULL) {
        printf("[%s]:[%d] open adc file error\r\n", __FUNCTION__, __LINE__);
        return -1;
    }
    memset(read_buf, 0, sizeof(read_buf));
    fread(read_buf, sizeof(read_buf), 1, fp);
    value = strtol(read_buf, NULL, 10);
    fclose(fp);
    return value;
}
#endif // 0

void set_recording_state(bool state) {
    pthread_mutex_lock(&recording_mutex);
    recording = state;
    pthread_mutex_unlock(&recording_mutex);

    if (recording) {
        led_blue_show(LED_BLINK);
		led_strip_show(true);
        //led_button_show(true);
        start_camera_recording();
    } else {
        stop_camera_recording();
        led_blue_show(LED_SOLID);
        //led_button_show(false);
		led_strip_show(true);
    }
}

bool get_recording_state() {
    pthread_mutex_lock(&recording_mutex);
    bool state = recording;
    pthread_mutex_unlock(&recording_mutex);
    return state;
}

void trigger_power_action() {
    printf("Shutting down the system\n");		
	system("shutdown -h now");
}

void *ble_button_thread(void *arg) {
    int btn_val;
    while (1) {
        btn_val = get_ble_button();
        if (btn_val == BTN_TOUCH || btn_val == 0x1d) {
            set_recording_state(!get_recording_state());
            usleep(500000);  // 500ms debounce
        }
        usleep(100000);  // 100ms polling interval
    }
    return NULL;
}

void *adc_button_thread(void *arg) {
    int fd, epoll_fd = 0;
    char buf[2] = {};
    struct epoll_event ev = {0};
	
	// Open GPIO value file
    fd = open(GPIO_PATH, O_RDONLY);
    if (fd < 0) {
        perror("Failed to open GPIO");
        return NULL;
    }

    // Create epoll instance
    epoll_fd = epoll_create1(0);
    if (epoll_fd < 0) {
        perror("Failed to create epoll instance");
        return NULL;
    }

    // Configure epoll to monitor GPIO file descriptor for input
    ev.events = EPOLLPRI | EPOLLET;  // Edge-triggered
    ev.data.fd = fd;
    if (epoll_ctl(epoll_fd, EPOLL_CTL_ADD, fd, &ev) < 0) {
        perror("Failed to add GPIO to epoll");
        return NULL;
    }

    printf("Monitoring GPIO %s for button press...\n", GPIO_PIN);

    while (1) {
        struct epoll_event events[1] = {0};

        // Wait for GPIO input event
        int event_count = epoll_wait(epoll_fd, events, 1, -1);
        if (event_count < 0) {
            perror("Epoll wait failed");
            break;
        }

        // Read GPIO value
        lseek(fd, 0, SEEK_SET);
        read(fd, buf, 1);

        if (buf[0] == '0') {  // Assuming active-low button
            usleep(DEBOUNCE_TIME * 1000);  // Debounce delay
            trigger_power_action();
        }
    }

    close(fd);
    close(epoll_fd);
    return NULL;
}

void initialize_camera_system() {
    // Nothing to initialize - we'll start fresh each time
    printf("Camera system ready.\n");
}

void start_camera_recording() {
    // Kill any existing instances first
    system("pkill -f cam_skel-record.py");
    usleep(200000);  // Wait for cleanup
    
    char time_buf[30];
    get_time(time_buf);
    char command[256];
    snprintf(command, sizeof(command), 
        "python3.11 /home/khadas/prog/app_demo/camera/cam_skel-record.py %s --action start &",
        time_buf);
    system(command);
    printf("Recording started.\n");
}

void stop_camera_recording() {
    system("pkill -f cam_skel-record.py");
    usleep(200000);  // 200ms delay
    printf("Recording stopped.\n");
}

void cleanup_camera_system() {
    stop_camera_recording();
    printf("Camera system cleaned up.\n");
}

void *imu_acc_thread(void *arg) {
    int ret;
    float xy;
    float acc_last = 0;
    float acc_sum = 0;
    float acc_derta;
    int sample_times = 10;
    u8 trigger_count = 0;

    while (1) {
        acc_sum = 0;
        for (int i = 0; i < sample_times; i++) {
            ret = bno055_get_accxy(&xy);
            if (ret == 0) {
                acc_sum += xy;
                usleep(100 * 1000);
            }
        }
        /*
        acc_derta = acc_sum/sample_times - acc_last;
        acc_last = acc_sum/sample_times;
        fabs(acc_derta) > 5 ? trigger_count++ : (trigger_count = 0);
        if (trigger_count >= 3) {
            trigger_count = 0;
            if (!get_recording_state()) {
                set_recording_state(true);
                sleep(30);
            }
        }*/
    }
    return NULL;
}

void sig_handler(int sig) {
    if (sig == SIGINT) {
        printf("Received SIGINT, stopping recording and exiting...\n");
        set_recording_state(false);
        cleanup_camera_system();
        exit(0);
    }
}

int main(int argc, char *argv[]) {
    int ret = 0;
    int gps_port = 0;
    int gps_fd = 0;
    int imu_fd = 0;
    pthread_t ble_tid, adc_tid, imu_tid = 0;
    char gps_data[256] = "";
    char imu_data[256] = "";
    char time_buf[30] = "";
    char file_name[80] = "";

    signal(SIGINT, sig_handler);
    
    initialize_camera_system();
    bno055_start();
    gps_port = gps_open();
    led_blue_show(LED_SOLID);
    led_strip_show(true);
    get_time(time_buf);

    if (pthread_create(&ble_tid, NULL, ble_button_thread, NULL)) {
        printf("Create BLE button pthread failed\n");
        return -1;
    }
    pthread_detach(ble_tid);

    if (pthread_create(&adc_tid, NULL, adc_button_thread, NULL)) {
        printf("Create ADC button pthread failed\n");
        return -1;
    }
    pthread_detach(adc_tid);

    if (pthread_create(&imu_tid, NULL, imu_acc_thread, NULL)) {
        printf("Create IMU pthread failed\n");
        return -1;
    }
    pthread_detach(imu_tid);

    while (1) {
         if (get_recording_state()) {
            // Open GPS and IMU files
            get_time(time_buf);
            sprintf(file_name, "/home/khadas/data/gps_%s.csv", time_buf);
            gps_fd = creat(file_name, 0666);
            sprintf(file_name, "/home/khadas/data/imu_%s.csv", time_buf);
            imu_fd = creat(file_name, 0666);

            // Record loop
            while (get_recording_state()) {
                ret = gps_outdata(gps_port, gps_data, sizeof(gps_data));
                if (ret > 0) {
                    ret = write(gps_fd, gps_data, ret);
                    printf("Gps:%d ", ret);
                }
                usleep(300 * 1000);

                ret = bno055_data(imu_data, sizeof(imu_data));
                if (ret > 0) {
                    ret = write(imu_fd, imu_data, ret);
                    printf("Imu:%d ", ret);
                }

                usleep(100 * 1000);
            }

            // Close GPS and IMU files
            close(gps_fd);
            close(imu_fd);
        }
	sleep(1);
    }

    // Cleanup code
    led_strip_show(false);
    gps_close(gps_port);
    bno055_stop();
    cleanup_camera_system();

    return 0;
}
